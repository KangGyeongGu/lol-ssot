{
  "run_id": "20260212-211025",
  "status": "fail",
  "fail_on": "high",
  "generated_at": "2026-02-12T12:26:03+00:00",
  "mode": "full",
  "dry_run": false,
  "task_count": 19,
  "severity_totals": {
    "critical": 3,
    "high": 10,
    "medium": 20,
    "low": 2
  },
  "area_matrix": [
    {
      "task_id": "AREA-01_PRODUCT",
      "target_id": "01_PRODUCT",
      "agent_id": "area-auditor",
      "status": "pass",
      "max_severity": "low",
      "finding_count": 0,
      "summary": "01_PRODUCT required documents are present, internal references resolve, scope boundaries are explicitly declared, and normative statements are clear without redefining other area ownership."
    },
    {
      "task_id": "AREA-02_DESIGN",
      "target_id": "02_DESIGN",
      "agent_id": "area-auditor",
      "status": "warn",
      "max_severity": "medium",
      "finding_count": 2,
      "summary": "Validated 11 markdown files in 02_DESIGN. All 22 in-scope links resolved and token definitions are internally consistent, but 2 medium issues were found in scope-boundary clarity and required-doc ownership clarity."
    },
    {
      "task_id": "AREA-03_API",
      "target_id": "03_API",
      "agent_id": "area-auditor",
      "status": "warn",
      "max_severity": "medium",
      "finding_count": 2,
      "summary": "Found 2 medium integrity issues in 03_API lifecycle/page-map alignment; required documents exist and checked in-scope links resolve."
    },
    {
      "task_id": "AREA-04_DOMAIN",
      "target_id": "04_DOMAIN",
      "agent_id": "area-auditor",
      "status": "warn",
      "max_severity": "medium",
      "finding_count": 1,
      "summary": "04_DOMAIN documents are present and linked, but persistence timing semantics are ambiguous for several persistent entities during Phase 2."
    },
    {
      "task_id": "AREA-05_FRONTEND",
      "target_id": "05_FRONTEND",
      "agent_id": "area-auditor",
      "status": "fail",
      "max_severity": "high",
      "finding_count": 2,
      "summary": "Found 2 issues (1 high, 1 medium): a PageRoute contract mismatch between frontend routing specs and upstream API conventions, and UI copy ownership drift inside frontend notification rules. Required frontend docs are present and scoped wiki-links resolve."
    },
    {
      "task_id": "AREA-06_BACKEND",
      "target_id": "06_BACKEND",
      "agent_id": "area-auditor",
      "status": "warn",
      "max_severity": "medium",
      "finding_count": 2,
      "summary": "Scoped backend SSOT audit found 2 issues: one required-doc manifest drift in README and one medium test-rule traceability gap for data write-policy rules. No broken markdown/wiki links were found in `06_BACKEND` documents."
    }
  ],
  "relation_matrix": [
    {
      "task_id": "REL-API-BACKEND",
      "target_id": "API_BACKEND",
      "agent_id": "relation-auditor",
      "status": "pass",
      "max_severity": "low",
      "finding_count": 0,
      "summary": "Backend API/realtime implementation-rule documents consistently reference `03_API` as contract SSOT, and no API↔backend rule conflicts or relation-level duplication were found within the scoped paths."
    },
    {
      "task_id": "REL-API-FRONTEND",
      "target_id": "API_FRONTEND",
      "agent_id": "relation-auditor",
      "status": "fail",
      "max_severity": "high",
      "finding_count": 2,
      "summary": "Frontend routing SSOT drifts from API contract SSOT on PageRoute usage: FE rules currently include non-contract route values as PageRoute and overgeneralize pageRoute-driven transitions."
    },
    {
      "task_id": "REL-DESIGN-FRONTEND",
      "target_id": "DESIGN_FRONTEND",
      "agent_id": "relation-auditor",
      "status": "warn",
      "max_severity": "medium",
      "finding_count": 2,
      "summary": "Frontend documents correctly reference design token and page-requirement sources, but two medium relation-drift issues remain around ownership and scope clarity between design requirements and frontend consumption rules."
    },
    {
      "task_id": "REL-DOMAIN-API",
      "target_id": "DOMAIN_API",
      "agent_id": "relation-auditor",
      "status": "warn",
      "max_severity": "medium",
      "finding_count": 2,
      "summary": "Found 2 medium DOMAIN_API consistency issues: one-way cross-area references (DOMAIN->API only) and a stage mapping drift in ROOM_GAME_STARTED."
    },
    {
      "task_id": "REL-DOMAIN-BACKEND",
      "target_id": "DOMAIN_BACKEND",
      "agent_id": "relation-auditor",
      "status": "fail",
      "max_severity": "high",
      "finding_count": 1,
      "summary": "Found a high-severity domain-to-backend mapping mismatch: backend write-back timing rule does not preserve the domain SSOT’s per-entity timing requirements."
    },
    {
      "task_id": "REL-PRODUCT-API",
      "target_id": "PRODUCT_API",
      "agent_id": "relation-auditor",
      "status": "fail",
      "max_severity": "high",
      "finding_count": 2,
      "summary": "Found 2 PRODUCT_API relation issues: 1 high mapping conflict in lifecycle REST routing and 1 medium requirement-to-contract traceability gap."
    },
    {
      "task_id": "REL-PRODUCT-DESIGN",
      "target_id": "PRODUCT_DESIGN",
      "agent_id": "relation-auditor",
      "status": "fail",
      "max_severity": "critical",
      "finding_count": 3,
      "summary": "Detected PRODUCT_DESIGN SSOT relation failures: direct cross-area references are missing, intent-to-design mapping is implicit, and behavioral rules are duplicated across Product and Design without explicit ownership links."
    }
  ],
  "duplication_matrix": [
    {
      "task_id": "DUP-NORMATIVE",
      "target_id": "NORMATIVE_DUPLICATION",
      "agent_id": "duplication-auditor",
      "status": "fail",
      "max_severity": "high",
      "finding_count": 3,
      "summary": "Detected duplicated/conflicting normative rules across SSOT areas, including one high-severity conflict on UI message SSOT ownership/keyspace that creates mutually incompatible implementation guidance."
    },
    {
      "task_id": "DUP-OWNERSHIP",
      "target_id": "OWNERSHIP_VIOLATION",
      "agent_id": "duplication-auditor",
      "status": "fail",
      "max_severity": "critical",
      "finding_count": 2,
      "summary": "Found 2 ownership violations in scope. A critical SSOT breach exists where Frontend docs redefine Product-owned UI copy SSOT, and additional cross-area ownership drift statements assign copy ownership to Frontend from Design/Frontend docs."
    },
    {
      "task_id": "DUP-TERMINOLOGY",
      "target_id": "TERM_CONFLICT",
      "agent_id": "duplication-auditor",
      "status": "fail",
      "max_severity": "high",
      "finding_count": 2,
      "summary": "Detected 2 terminology issues in scope: 1 high-severity `PageRoute` definition conflict and 1 medium-severity route/state alias ambiguity (`ROOM_LIST`)."
    }
  ],
  "agent_spec_matrix": [
    {
      "task_id": "AGENTSPEC-BACKEND",
      "target_id": "BACKEND_AGENT_SKILL",
      "agent_id": "agent-spec-auditor",
      "status": "fail",
      "max_severity": "high",
      "finding_count": 2,
      "summary": "Backend agent/skill wiring is mostly consistent, but one high-severity mandatory reference path issue and one medium traceability reference issue were found within the scoped specs."
    },
    {
      "task_id": "AGENTSPEC-FRONTEND",
      "target_id": "FRONTEND_AGENT_SKILL",
      "agent_id": "agent-spec-auditor",
      "status": "pass",
      "max_severity": "low",
      "finding_count": 0,
      "summary": "Validated FRONTEND and COMMON agent/skill wiring within scope; role coverage, domain mappings, required references, and master-subskill bindings are consistent with SSOT expectations and no violations were found."
    }
  ],
  "traceability_matrix": [
    {
      "task_id": "TRACE-E2E",
      "target_id": "E2E_TRACEABILITY",
      "agent_id": "traceability-auditor",
      "status": "fail",
      "max_severity": "critical",
      "finding_count": 5,
      "summary": "End-to-end traceability is broken by missing Product→Design source links, API lifecycle mapping conflict, Domain→Backend write-policy timing mismatch, API→Frontend PageRoute mismatch, and one orphaned/mislocated spec declaration."
    }
  ],
  "top_findings": [
    {
      "task_id": "REL-PRODUCT-DESIGN",
      "agent_id": "relation-auditor",
      "target_kind": "relation",
      "target_id": "PRODUCT_DESIGN",
      "severity": "critical",
      "code": "REL_MISSING_MANDATORY_CROSS_REF",
      "message": "Mandatory PRODUCT_DESIGN relationship is not explicitly documented: Product core requirements only reference Product docs, while Design requirements reference API docs only and omit Product sources.",
      "evidence": [
        {
          "path": "01_PRODUCT/REQUIREMENTS.md",
          "line": 5,
          "snippet": "## 관련 문서"
        },
        {
          "path": "01_PRODUCT/REQUIREMENTS.md",
          "line": 6,
          "snippet": "- [[01_PRODUCT/GAME_RULES.md]]"
        },
        {
          "path": "02_DESIGN/README.md",
          "line": 28,
          "snippet": "- 페이지 요구사항(데이터/상태/상호작용)은 `03_API/PAGE_MAP/`과 일치해야 한다."
        },
        {
          "path": "02_DESIGN/PAGE_REQUIREMENTS/MAIN.md",
          "line": 4,
          "snippet": "## 관련 문서"
        },
        {
          "path": "02_DESIGN/PAGE_REQUIREMENTS/MAIN.md",
          "line": 5,
          "snippet": "- [[03_API/PAGE_MAP/MAIN.md]]"
        }
      ],
      "proposed_fix": "Add explicit PRODUCT_DESIGN links in both directions: each `02_DESIGN/PAGE_REQUIREMENTS/*.md` should cite source clauses in `01_PRODUCT/REQUIREMENTS.md` and/or `01_PRODUCT/USER_FLOWS.md`, and Product should reference corresponding Design requirement docs for downstream realization."
    },
    {
      "task_id": "DUP-OWNERSHIP",
      "agent_id": "duplication-auditor",
      "target_kind": "duplication",
      "target_id": "OWNERSHIP_VIOLATION",
      "severity": "critical",
      "code": "source_of_truth_violation.copy_ssot_redefined",
      "message": "`05_FRONTEND/FE_NOTIFICATION_MESSAGES.md` redefines Product-owned UI copy by declaring itself the single document for message keys/Korean text and providing canonical copy mappings, while Product explicitly owns UI copy SSOT in `01_PRODUCT/COPY_TEXT.md`.",
      "evidence": [
        {
          "path": "01_PRODUCT/README.md",
          "line": 6,
          "snippet": "- 포함: 요구사항, 유저 플로우, 게임 규칙, 경제/카탈로그, UI 카피"
        },
        {
          "path": "01_PRODUCT/COPY_TEXT.md",
          "line": 2,
          "snippet": "- UI 문구는 이 파일이 단일 진실"
        },
        {
          "path": "05_FRONTEND/FE_NOTIFICATION_MESSAGES.md",
          "line": 2,
          "snippet": "- 알림 컴포넌트에서 사용하는 메시지 키와 한국어 문구를 단일 문서로 정의한다."
        },
        {
          "path": "05_FRONTEND/FE_NOTIFICATION_MESSAGES.md",
          "line": 17,
          "snippet": "| error.code ... | messageKey ... | ko ... |"
        }
      ],
      "proposed_fix": "Move canonical alert/message keys and Korean copy definitions into `01_PRODUCT/COPY_TEXT.md` (or a Product-owned copy SSOT file), and convert `05_FRONTEND/FE_NOTIFICATION_MESSAGES.md` into implementation guidance that only references Product-owned keys."
    },
    {
      "task_id": "TRACE-E2E",
      "agent_id": "traceability-auditor",
      "target_kind": "traceability",
      "target_id": "E2E_TRACEABILITY",
      "severity": "critical",
      "code": "TRACE_REQ_DESIGN_MANDATORY_LINK_MISSING",
      "message": "The requirement-to-design segment is missing explicit mandatory references: Product requirement sources link only within `01_PRODUCT`, while Design page requirements link directly to API docs, leaving the `requirement -> design -> api` chain non-deterministic.",
      "evidence": [
        {
          "path": "01_PRODUCT/REQUIREMENTS.md",
          "line": 5,
          "snippet": "## 관련 문서"
        },
        {
          "path": "01_PRODUCT/REQUIREMENTS.md",
          "line": 6,
          "snippet": "- [[01_PRODUCT/GAME_RULES.md]]"
        },
        {
          "path": "01_PRODUCT/USER_FLOWS.md",
          "line": 7,
          "snippet": "## 관련 문서"
        },
        {
          "path": "02_DESIGN/PAGE_REQUIREMENTS/MAIN.md",
          "line": 5,
          "snippet": "- [[03_API/PAGE_MAP/MAIN.md]]"
        },
        {
          "path": "02_DESIGN/README.md",
          "line": 28,
          "snippet": "- 페이지 요구사항(데이터/상태/상호작용)은 `03_API/PAGE_MAP/`과 일치해야 한다."
        }
      ],
      "proposed_fix": "Add explicit `Source Requirement` links (section-level anchors) from each `02_DESIGN/PAGE_REQUIREMENTS/*.md` to `01_PRODUCT/REQUIREMENTS.md` and/or `01_PRODUCT/USER_FLOWS.md`, and add reverse links from Product pages to corresponding Design specs."
    },
    {
      "task_id": "AREA-05_FRONTEND",
      "agent_id": "area-auditor",
      "target_kind": "area",
      "target_id": "05_FRONTEND",
      "severity": "high",
      "code": "ROUTING_PAGE_ROUTE_CONTRACT_MISMATCH",
      "message": "Frontend routing rules treat multiple app routes as API `PageRoute` values, but upstream REST conventions restrict `PageRoute` to three values (`WAITING_ROOM`, `BAN_PICK_SHOP`, `IN_GAME`), creating a routing/API contract mismatch.",
      "evidence": [
        {
          "path": "05_FRONTEND/FE_ROUTING_RULES.md",
          "line": 14,
          "snippet": "Route name은 `PageRoute`와 동일한 대문자 식별자를 사용한다."
        },
        {
          "path": "05_FRONTEND/FE_ROUTING_RULES.md",
          "line": 16,
          "snippet": "예: `WELCOME`, `MAIN`, `ROOM_LIST`, `WAITING_ROOM`, `BAN_PICK_SHOP`, `IN_GAME`, `RESULT`, `MY_PAGE`"
        },
        {
          "path": "05_FRONTEND/FE_ROUTING_RULES.md",
          "line": 27,
          "snippet": "API 응답의 `pageRoute`가 유일한 전환 기준이다."
        },
        {
          "path": "05_FRONTEND/FE_DESIGN_MAPPING.md",
          "line": 15,
          "snippet": "| WELCOME | [[02_DESIGN/PAGE_REQUIREMENTS/LOGIN.md]] | 로그인/인증 진입"
        },
        {
          "path": "03_API/CONTRACT/REST/CONVENTIONS.md",
          "line": 137,
          "snippet": "PageRoute 값은 다음 3개만 사용한다."
        },
        {
          "path": "03_API/CONTRACT/REST/CONVENTIONS.md",
          "line": 138,
          "snippet": "- `WAITING_ROOM`"
        },
        {
          "path": "03_API/CONTRACT/REST/CONVENTIONS.md",
          "line": 139,
          "snippet": "- `BAN_PICK_SHOP`"
        },
        {
          "path": "03_API/CONTRACT/REST/CONVENTIONS.md",
          "line": 140,
          "snippet": "- `IN_GAME`"
        }
      ],
      "proposed_fix": "Separate frontend app routes from API `PageRoute` (e.g., `AppRoute` vs `ApiPageRoute`) or align FE route lists to the API contract, then update `05_FRONTEND/FE_ROUTING_RULES.md` and `05_FRONTEND/FE_DESIGN_MAPPING.md` accordingly."
    },
    {
      "task_id": "REL-API-FRONTEND",
      "agent_id": "relation-auditor",
      "target_kind": "relation",
      "target_id": "API_FRONTEND",
      "severity": "high",
      "code": "PAGE_ROUTE_ENUM_MISMATCH",
      "message": "`05_FRONTEND` routing rules redefine `PageRoute` with values outside the API contract (`WELCOME`, `MAIN`, `RESULT`, `MY_PAGE`), conflicting with API SSOT enum constraints.",
      "evidence": [
        {
          "path": "05_FRONTEND/FE_ROUTING_RULES.md",
          "line": 14,
          "snippet": "Route name은 `PageRoute`와 동일한 대문자 식별자를 사용한다."
        },
        {
          "path": "05_FRONTEND/FE_ROUTING_RULES.md",
          "line": 16,
          "snippet": "예: `WELCOME`, `MAIN`, `WAITING_ROOM`, `BAN_PICK_SHOP`, `IN_GAME`, `RESULT`, `MY_PAGE`"
        },
        {
          "path": "03_API/CONTRACT/REST/CONVENTIONS.md",
          "line": 137,
          "snippet": "PageRoute 값은 다음 3개만 사용한다."
        },
        {
          "path": "03_API/CONTRACT/REST/OPENAPI.yaml.md",
          "line": 129,
          "snippet": "PageRoute enum: [WAITING_ROOM, BAN_PICK_SHOP, IN_GAME]"
        }
      ],
      "proposed_fix": "`05_FRONTEND/FE_ROUTING_RULES.md`에서 `PageRoute`를 active-game 복귀용 3개 값으로 한정하고, 일반 화면 라우트 식별자는 별도 타입(예: `AppRoute`)으로 분리해 정의한다."
    },
    {
      "task_id": "REL-DOMAIN-BACKEND",
      "agent_id": "relation-auditor",
      "target_kind": "relation",
      "target_id": "DOMAIN_BACKEND",
      "severity": "high",
      "code": "DOMAIN_BACKEND_WRITE_POLICY_TIMING_MISMATCH",
      "message": "`06_BACKEND/BE_DATA_MODEL_RULES.md` defines write-back persistence timing as a single rule (`GAME_FINISHED` or room/game end), but domain SSOT requires different timing by entity group (ROOM* at `startGame`, GAME* at `GAME_FINISHED`). This can cause backend orchestration/persistence behavior to diverge from domain SSOT.",
      "evidence": [
        {
          "path": "06_BACKEND/BE_DATA_MODEL_RULES.md",
          "line": 19,
          "snippet": "- write-back 대상은 GAME_FINISHED 또는 룸/게임 종료 시 DB 반영이 필수다."
        },
        {
          "path": "04_DOMAIN/DATA_MODEL.md",
          "line": 58,
          "snippet": "| ROOM | write-back | 로비 상태는 Redis에서 관리, 게임 시작 시 DB 스냅샷 저장 |"
        },
        {
          "path": "04_DOMAIN/DATA_MODEL.md",
          "line": 62,
          "snippet": "| GAME | write-back | 진행 상태는 Redis에서 관리, GAME_FINISHED 시 DB 저장 |"
        },
        {
          "path": "04_DOMAIN/REDIS_DB_TIMING.md",
          "line": 26,
          "snippet": "| Phase 1: 게임 시작 | startGame | 스냅샷 고정 | 1차 DB flush | ROOM, ROOM_PLAYER, ROOM_KICK, ROOM_HOST_HISTORY, GAME, GAME_PLAYER |"
        },
        {
          "path": "04_DOMAIN/REDIS_DB_TIMING.md",
          "line": 28,
          "snippet": "| Phase 3: 게임 종료 | GAME_FINISHED | 최종 스냅샷 | 2차 DB flush | GAME, GAME_PLAYER, GAME_BAN, GAME_PICK, USER(coin/exp/score) |"
        }
      ],
      "proposed_fix": "Update `06_BACKEND/BE_DATA_MODEL_RULES.md` to mirror domain SSOT timing by entity group: `ROOM/ROOM_PLAYER/ROOM_KICK/ROOM_HOST_HISTORY` flush at `startGame`, and `GAME/GAME_PLAYER/GAME_BAN/GAME_PICK` flush at `GAME_FINISHED`; keep wording aligned with `04_DOMAIN/DATA_MODEL.md` and `04_DOMAIN/REDIS_DB_TIMING.md`."
    },
    {
      "task_id": "REL-PRODUCT-API",
      "agent_id": "relation-auditor",
      "target_kind": "relation",
      "target_id": "PRODUCT_API",
      "severity": "high",
      "code": "LIFECYCLE_BAN_PICK_ENDPOINT_CONFLICT",
      "message": "`03_API/LIFECYCLE.md` has conflicting REST mappings for BAN/PICK/SHOP. Section 3.3 lists distinct endpoints (`/ban`, `/pick`, `/shop/purchase`), but section 5.3 maps BAN/PICK/SHOP to only `/shop/purchase`, which can miswire client orchestration against product flow and page-map contracts.",
      "evidence": [
        {
          "path": "03_API/LIFECYCLE.md",
          "line": 73,
          "snippet": "- REST `/games/{gameId}/ban`, `/pick`, `/shop/purchase`"
        },
        {
          "path": "03_API/LIFECYCLE.md",
          "line": 137,
          "snippet": "| BAN/PICK/SHOP 구매         | `POST /games/{gameId}/shop/purchase` | 밴/픽/구매 처리              |"
        },
        {
          "path": "03_API/PAGE_MAP/BAN_PICK_SHOP.md",
          "line": 23,
          "snippet": "| BAN | 알고리즘 밴 제출 | POST | /games/{gameId}/ban |"
        },
        {
          "path": "03_API/PAGE_MAP/BAN_PICK_SHOP.md",
          "line": 24,
          "snippet": "| PICK | 알고리즘 픽 제출 | POST | /games/{gameId}/pick |"
        }
      ],
      "proposed_fix": "In `03_API/LIFECYCLE.md` section 5.3, split BAN/PICK/SHOP into separate rows and map each to the correct endpoint (`/ban`, `/pick`, `/shop/purchase`) to match PAGE_MAP and OPENAPI contracts."
    },
    {
      "task_id": "DUP-NORMATIVE",
      "agent_id": "duplication-auditor",
      "target_kind": "duplication",
      "target_id": "NORMATIVE_DUPLICATION",
      "severity": "high",
      "code": "NORMATIVE_CONFLICT_UI_MESSAGE_SSOT",
      "message": "UI message source-of-truth rules conflict across PRODUCT and FRONTEND: one rule requires all UI text to come from COPY_TEXT keys, while another defines a separate notification-message SSOT with ERROR/NOTICE keyspace and localized text in FRONTEND docs.",
      "evidence": [
        {
          "path": "01_PRODUCT/COPY_TEXT.md",
          "line": 2,
          "snippet": "- UI 문구는 이 파일이 단일 진실"
        },
        {
          "path": "05_FRONTEND/FE_CONVENTIONS.md",
          "line": 54,
          "snippet": "- 모든 문구는 [[01_PRODUCT/COPY_TEXT.md]] 키를 사용한다."
        },
        {
          "path": "05_FRONTEND/FE_API_CLIENT.md",
          "line": 34,
          "snippet": "- UI 메시지는 [[01_PRODUCT/COPY_TEXT.md]] 키로만 표시한다."
        },
        {
          "path": "05_FRONTEND/FE_NOTIFICATION_MESSAGES.md",
          "line": 2,
          "snippet": "- 알림 컴포넌트에서 사용하는 메시지 키와 한국어 문구를 단일 문서로 정의한다."
        },
        {
          "path": "05_FRONTEND/FE_NOTIFICATION_MESSAGES.md",
          "line": 3,
          "snippet": "- 에러 알림은 `ERROR.<CODE>` 키를 사용한다."
        },
        {
          "path": "05_FRONTEND/FE_STATE_RULES.md",
          "line": 46,
          "snippet": "- 이벤트 기반 알림은 `NOTICE.*` 키를 사용한다."
        }
      ],
      "proposed_fix": "Define one canonical ownership model: either (a) move ERROR/NOTICE message keys and localized strings into 01_PRODUCT/COPY_TEXT.md and make FE docs reference-only, or (b) carve out explicit notification exceptions in FE_CONVENTIONS/FE_API_CLIENT and update 01_PRODUCT/COPY_TEXT.md scope text accordingly."
    },
    {
      "task_id": "DUP-TERMINOLOGY",
      "agent_id": "duplication-auditor",
      "target_kind": "duplication",
      "target_id": "TERM_CONFLICT",
      "severity": "high",
      "code": "TERM_DEFINITION_CONFLICT_PAGEROUTE",
      "message": "`PageRoute` has conflicting definitions across SSOT areas. API contracts define it as a 3-value active-game routing enum, while frontend routing rules redefine/expand it as general app routes (`WELCOME`, `MAIN`, `RESULT`, `MY_PAGE`, etc.) and require route naming to match `PageRoute`.",
      "evidence": [
        {
          "path": "03_API/CONTRACT/REST/CONVENTIONS.md",
          "line": 137,
          "snippet": "PageRoute 값은 다음 3개만 사용한다."
        },
        {
          "path": "03_API/CONTRACT/REST/OPENAPI.yaml.md",
          "line": 131,
          "snippet": "enum: [WAITING_ROOM, BAN_PICK_SHOP, IN_GAME]"
        },
        {
          "path": "05_FRONTEND/FE_ROUTING_RULES.md",
          "line": 14,
          "snippet": "Route name은 `PageRoute`와 동일한 대문자 식별자를 사용한다."
        },
        {
          "path": "05_FRONTEND/FE_ROUTING_RULES.md",
          "line": 16,
          "snippet": "예: `WELCOME`, `MAIN`, `WAITING_ROOM`, `BAN_PICK_SHOP`, `IN_GAME`, `RESULT`, `MY_PAGE`"
        },
        {
          "path": "05_FRONTEND/FE_ROUTING_RULES.md",
          "line": 27,
          "snippet": "API 응답의 `pageRoute`가 유일한 전환 기준이다."
        }
      ],
      "proposed_fix": "Reserve `PageRoute` for API active-game values only (`WAITING_ROOM`, `BAN_PICK_SHOP`, `IN_GAME`). Introduce a separate term (e.g., `AppRoute`) for full frontend navigation routes and document explicit mapping between `pageRoute` -> `AppRoute` where needed."
    },
    {
      "task_id": "AGENTSPEC-BACKEND",
      "agent_id": "agent-spec-auditor",
      "target_kind": "agent_spec",
      "target_id": "BACKEND_AGENT_SKILL",
      "severity": "high",
      "code": "required_reference_existence.partial_review_docs_path_missing",
      "message": "Partial review orchestration requires reading the latest SSOT commit from `../docs`, but that path is absent in this repository environment, creating a blocking wiring dependency for `/be-review-partial`.",
      "evidence": [
        {
          "path": "AGENTS/CLAUDE/AGENTS/BACKEND/REVIEW/BE_REVIEW_PARTIAL_MASTER_AGENT.md",
          "line": 15,
          "snippet": "Detect the latest SSOT submodule commit (expected at `../docs`)."
        },
        {
          "path": "AGENTS/CLAUDE/SKILLS/BACKEND/REVIEW/be-review-partial/SKILL.md",
          "line": 14,
          "snippet": "Use Bash to read the latest SSOT submodule commit from `../docs` and validate the partial commit convention."
        },
        {
          "path": "../docs",
          "snippet": "Directory does not exist relative to `/Users/kanggyeonggu/Documents/league-of-algologic`."
        }
      ],
      "proposed_fix": "Make the docs location configurable (e.g., env var or skill input), validate existence before execution, and add a fallback prompt when unavailable. If `../docs` is truly mandatory, document/bootstrap that dependency so the path is always present."
    },
    {
      "task_id": "TRACE-E2E",
      "agent_id": "traceability-auditor",
      "target_kind": "traceability",
      "target_id": "E2E_TRACEABILITY",
      "severity": "high",
      "code": "TRACE_API_BAN_PICK_SHOP_MAPPING_CONFLICT",
      "message": "API lifecycle documentation contains conflicting BAN/PICK/SHOP REST mappings, which can miswire requirement/design-driven orchestration.",
      "evidence": [
        {
          "path": "03_API/LIFECYCLE.md",
          "line": 73,
          "snippet": "- REST `/games/{gameId}/ban`, `/pick`, `/shop/purchase`"
        },
        {
          "path": "03_API/LIFECYCLE.md",
          "line": 137,
          "snippet": "| BAN/PICK/SHOP 구매         | `POST /games/{gameId}/shop/purchase` | 밴/픽/구매 처리              |"
        },
        {
          "path": "03_API/PAGE_MAP/BAN_PICK_SHOP.md",
          "line": 23,
          "snippet": "| BAN | 알고리즘 밴 제출 | POST | /games/{gameId}/ban |"
        },
        {
          "path": "03_API/PAGE_MAP/BAN_PICK_SHOP.md",
          "line": 24,
          "snippet": "| PICK | 알고리즘 픽 제출 | POST | /games/{gameId}/pick |"
        },
        {
          "path": "03_API/PAGE_MAP/BAN_PICK_SHOP.md",
          "line": 25,
          "snippet": "| SHOP | 아이템/스펠 일괄 구매 | POST | /games/{gameId}/shop/purchase |"
        }
      ],
      "proposed_fix": "In `03_API/LIFECYCLE.md` section 5.3, split BAN, PICK, and SHOP into separate rows with the correct endpoints (`/ban`, `/pick`, `/shop/purchase`) so lifecycle, page-map, and downstream implementation traces stay consistent."
    },
    {
      "task_id": "TRACE-E2E",
      "agent_id": "traceability-auditor",
      "target_kind": "traceability",
      "target_id": "E2E_TRACEABILITY",
      "severity": "high",
      "code": "TRACE_DOMAIN_BACKEND_WRITE_POLICY_TIMING_MISMATCH",
      "message": "The requirement-to-domain-to-backend chain is inconsistent for write-back timing: backend rule text allows a broad end-of-room/game flush, while domain SSOT requires phase-specific timing by entity group.",
      "evidence": [
        {
          "path": "06_BACKEND/BE_DATA_MODEL_RULES.md",
          "line": 19,
          "snippet": "- write-back 대상은 GAME_FINISHED 또는 룸/게임 종료 시 DB 반영이 필수다."
        },
        {
          "path": "04_DOMAIN/DATA_MODEL.md",
          "line": 58,
          "snippet": "| ROOM | write-back | 로비 상태는 Redis에서 관리, 게임 시작 시 DB 스냅샷 저장 |"
        },
        {
          "path": "04_DOMAIN/DATA_MODEL.md",
          "line": 62,
          "snippet": "| GAME | write-back | 진행 상태는 Redis에서 관리, GAME_FINISHED 시 DB 저장 |"
        },
        {
          "path": "04_DOMAIN/REDIS_DB_TIMING.md",
          "line": 26,
          "snippet": "| Phase 1: 게임 시작 | startGame | 스냅샷 고정 | 1차 DB flush | ROOM, ROOM_PLAYER, ROOM_KICK, ROOM_HOST_HISTORY, GAME, GAME_PLAYER |"
        },
        {
          "path": "04_DOMAIN/REDIS_DB_TIMING.md",
          "line": 28,
          "snippet": "| Phase 3: 게임 종료 | GAME_FINISHED | 최종 스냅샷 | 2차 DB flush | GAME, GAME_PLAYER, GAME_BAN, GAME_PICK, USER(coin/exp/score) |"
        }
      ],
      "proposed_fix": "Align `06_BACKEND/BE_DATA_MODEL_RULES.md` with domain timing semantics: ROOM* flush at `startGame`, GAME* flush at `GAME_FINISHED`, using the same entity-group mapping as `04_DOMAIN`."
    },
    {
      "task_id": "TRACE-E2E",
      "agent_id": "traceability-auditor",
      "target_kind": "traceability",
      "target_id": "E2E_TRACEABILITY",
      "severity": "high",
      "code": "TRACE_API_FRONTEND_PAGEROUTE_ENUM_MISMATCH",
      "message": "Frontend routing rules redefine API `PageRoute` scope, breaking API-to-frontend traceability for active-game routing decisions required by product flow.",
      "evidence": [
        {
          "path": "01_PRODUCT/USER_FLOWS.md",
          "line": 37,
          "snippet": "- active game 있음: 해당 게임의 현재 stage에 맞는 게임 페이지로 이동한다."
        },
        {
          "path": "03_API/CONTRACT/REST/CONVENTIONS.md",
          "line": 137,
          "snippet": "PageRoute 값은 다음 3개만 사용한다."
        },
        {
          "path": "03_API/CONTRACT/REST/OPENAPI.yaml.md",
          "line": 131,
          "snippet": "enum: [WAITING_ROOM, BAN_PICK_SHOP, IN_GAME]"
        },
        {
          "path": "05_FRONTEND/FE_ROUTING_RULES.md",
          "line": 14,
          "snippet": "- Route name은 `PageRoute`와 동일한 대문자 식별자를 사용한다."
        },
        {
          "path": "05_FRONTEND/FE_ROUTING_RULES.md",
          "line": 16,
          "snippet": "- 예: `WELCOME`, `MAIN`, `WAITING_ROOM`, `BAN_PICK_SHOP`, `IN_GAME`, `RESULT`, `MY_PAGE`"
        },
        {
          "path": "05_FRONTEND/FE_ROUTING_RULES.md",
          "line": 27,
          "snippet": "- API 응답의 `pageRoute`가 유일한 전환 기준이다."
        }
      ],
      "proposed_fix": "Use API `PageRoute` only for active-game transitions (`WAITING_ROOM`, `BAN_PICK_SHOP`, `IN_GAME`) and define a separate frontend route type (e.g., `AppRoute`) for general navigation."
    },
    {
      "task_id": "AREA-02_DESIGN",
      "agent_id": "area-auditor",
      "target_kind": "area",
      "target_id": "02_DESIGN",
      "severity": "medium",
      "code": "SSOT_SCOPE_BOUNDARY_LAYOUT_RULE",
      "message": "WAITING_ROOM page requirements define fixed grid placement rules, which conflicts with 02_DESIGN README scope that explicitly excludes layout/component positioning.",
      "evidence": [
        {
          "path": "02_DESIGN/README.md",
          "line": 7,
          "snippet": "- 제외: 화면 레이아웃, UI 배치, 컴포넌트 위치/크기, 픽셀 기반 목업"
        },
        {
          "path": "02_DESIGN/PAGE_REQUIREMENTS/WAITING_ROOM.md",
          "line": 25,
          "snippet": "- 플레이어 그리드에서 방장은 항상 1행 1열에 위치한다."
        },
        {
          "path": "02_DESIGN/PAGE_REQUIREMENTS/WAITING_ROOM.md",
          "line": 28,
          "snippet": "- 방장 변경 시 신규 방장은 1행 1열로 이동한다."
        }
      ],
      "proposed_fix": "Move fixed slot/grid placement rules to the frontend ownership area, or restate them as non-positional behavioral constraints so 02_DESIGN remains within token/data/state/interaction scope."
    },
    {
      "task_id": "AREA-02_DESIGN",
      "agent_id": "area-auditor",
      "target_kind": "area",
      "target_id": "02_DESIGN",
      "severity": "medium",
      "code": "REQUIRED_DOC_OWNERSHIP_AMBIGUITY",
      "message": "02_DESIGN README lists FE_NOTIFICATION_MESSAGES.md inside the 02_DESIGN file structure, but the document is missing in this area, creating required-doc and ownership ambiguity.",
      "evidence": [
        {
          "path": "02_DESIGN/README.md",
          "line": 24,
          "snippet": "FE_NOTIFICATION_MESSAGES.md # 알림 및 오류 메시지 정의"
        },
        {
          "path": "02_DESIGN/FE_NOTIFICATION_MESSAGES.md",
          "snippet": "File not found in 02_DESIGN scope"
        }
      ],
      "proposed_fix": "Either add 02_DESIGN/FE_NOTIFICATION_MESSAGES.md as design-owned SSOT, or remove it from 02_DESIGN README and explicitly point to the owning area document."
    },
    {
      "task_id": "AREA-03_API",
      "agent_id": "area-auditor",
      "target_kind": "area",
      "target_id": "03_API",
      "severity": "medium",
      "code": "API_LIFECYCLE_ENDPOINT_DRIFT",
      "message": "`LIFECYCLE.md` collapses BAN/PICK/SHOP actions into only `/games/{gameId}/shop/purchase`, which drifts from the canonical REST contracts that define separate `/ban` and `/pick` endpoints.",
      "evidence": [
        {
          "path": "03_API/LIFECYCLE.md",
          "line": 137,
          "snippet": "| BAN/PICK/SHOP 구매         | `POST /games/{gameId}/shop/purchase` | 밴/픽/구매 처리              |"
        },
        {
          "path": "03_API/CONTRACT/REST/API_SUMMARY.md",
          "line": 67,
          "snippet": "| 밴 제출 | POST | /games/{gameId}/ban | body: algorithmId |"
        },
        {
          "path": "03_API/CONTRACT/REST/API_SUMMARY.md",
          "line": 68,
          "snippet": "| 픽 제출 | POST | /games/{gameId}/pick | body: algorithmId |"
        }
      ],
      "proposed_fix": "Update the lifecycle REST timing table to list BAN, PICK, and SHOP as separate calls (`/games/{gameId}/ban`, `/games/{gameId}/pick`, `/games/{gameId}/shop/purchase`) to match SSOT contracts."
    },
    {
      "task_id": "AREA-03_API",
      "agent_id": "area-auditor",
      "target_kind": "area",
      "target_id": "03_API",
      "severity": "medium",
      "code": "API_TIME_SYNC_TRACEABILITY_GAP",
      "message": "`TIME_SYNC` on `/user/queue/time` is defined as a basic subscription in realtime contracts, but lifecycle diagrams and page-level subscription maps omit it, creating traceability drift for timing synchronization behavior.",
      "evidence": [
        {
          "path": "03_API/LIFECYCLE.md",
          "line": 25,
          "snippet": "   - `/user/queue/time`"
        },
        {
          "path": "03_API/LIFECYCLE.md",
          "line": 145,
          "snippet": "  B --> C[\"기본 구독:<br/>/user/queue/errors<br/>/user/queue/rooms<br/>/user/queue/inventory\"]"
        },
        {
          "path": "03_API/LIFECYCLE.md",
          "line": 180,
          "snippet": "  C->>WS: SUB /user/queue/errors, /user/queue/rooms, /user/queue/inventory"
        },
        {
          "path": "03_API/CONTRACT/REALTIME/TOPICS.md",
          "line": 25,
          "snippet": "| /user/queue/time | USER | TIME_SYNC | 시간 동기화 |"
        },
        {
          "path": "03_API/PAGE_MAP/MAIN.md",
          "line": 33,
          "snippet": "| /user/queue/errors | ERROR | 실시간 명령 실패 수신 |"
        }
      ],
      "proposed_fix": "Make treatment of `/user/queue/time` explicit and consistent: either add it to lifecycle diagrams and relevant PAGE_MAP subscription sections, or document it as a global non-page subscription with a clear cross-reference."
    },
    {
      "task_id": "AREA-04_DOMAIN",
      "agent_id": "area-auditor",
      "target_kind": "area",
      "target_id": "04_DOMAIN",
      "severity": "medium",
      "code": "DOMAIN_WRITE_POLICY_DRIFT",
      "message": "Persistent entities are defined with default write-through policy, but the Phase 2 timing table marks DB writes as \"필요 시 write-through\", creating ambiguous persistence semantics for runtime logs.",
      "evidence": [
        {
          "path": "04_DOMAIN/DATA_MODEL.md",
          "line": 53,
          "snippet": "- 기본값: persistent = write-through. 예외는 아래 표에 명시한다."
        },
        {
          "path": "04_DOMAIN/DB_NOTES.md",
          "line": 104,
          "snippet": "- 기본값: persistent는 write-through."
        },
        {
          "path": "04_DOMAIN/REDIS_DB_TIMING.md",
          "line": 27,
          "snippet": "| Phase 2: 게임 진행 | 인게임 이벤트 | 즉시 반영 | 필요 시 write-through | ITEM_USAGE, SPELL_USAGE, SUBMISSION, GAME_ITEM_PURCHASE, GAME_SPELL_PURCHASE |"
        }
      ],
      "proposed_fix": "Align Phase 2 wording with SSOT policy by defining these entities as always write-through, or explicitly add them as write-back exceptions in DATA_MODEL.md and DB_NOTES.md."
    },
    {
      "task_id": "AREA-05_FRONTEND",
      "agent_id": "area-auditor",
      "target_kind": "area",
      "target_id": "05_FRONTEND",
      "severity": "medium",
      "code": "COPY_SSOT_OWNERSHIP_DRIFT",
      "message": "Frontend docs conflict on copy ownership: conventions/API client require UI copy keys from `01_PRODUCT/COPY_TEXT.md`, while notification rules define Korean copy text directly in `05_FRONTEND`, weakening SSOT ownership clarity.",
      "evidence": [
        {
          "path": "05_FRONTEND/FE_CONVENTIONS.md",
          "line": 54,
          "snippet": "모든 문구는 [[01_PRODUCT/COPY_TEXT.md]] 키를 사용한다."
        },
        {
          "path": "05_FRONTEND/FE_API_CLIENT.md",
          "line": 34,
          "snippet": "UI 메시지는 [[01_PRODUCT/COPY_TEXT.md]] 키로만 표시한다."
        },
        {
          "path": "05_FRONTEND/README.md",
          "line": 30,
          "snippet": "제품 요구사항/카피: `01_PRODUCT/`"
        },
        {
          "path": "05_FRONTEND/FE_NOTIFICATION_MESSAGES.md",
          "line": 2,
          "snippet": "알림 컴포넌트에서 사용하는 메시지 키와 한국어 문구를 단일 문서로 정의한다."
        },
        {
          "path": "05_FRONTEND/FE_NOTIFICATION_MESSAGES.md",
          "line": 17,
          "snippet": "| error.code | messageKey | ko |"
        }
      ],
      "proposed_fix": "Keep `05_FRONTEND/FE_NOTIFICATION_MESSAGES.md` focused on error-code/key mapping and move canonical Korean copy ownership to `01_PRODUCT/COPY_TEXT.md` (or explicitly document delegated ownership to remove ambiguity)."
    },
    {
      "task_id": "AREA-06_BACKEND",
      "agent_id": "area-auditor",
      "target_kind": "area",
      "target_id": "06_BACKEND",
      "severity": "medium",
      "code": "TEST_RULE_COVERAGE_GAP_WRITE_POLICY",
      "message": "Backend data write-policy SSOT rules (write-through/write-back and GAME_FINISHED/termination flush semantics) are defined but not explicitly reflected in backend test-rule coverage statements, reducing rule-to-test traceability.",
      "evidence": [
        {
          "path": "06_BACKEND/BE_DATA_MODEL_RULES.md",
          "line": 17,
          "snippet": "- write-through: 상태 변경 즉시 DB에 기록한다."
        },
        {
          "path": "06_BACKEND/BE_DATA_MODEL_RULES.md",
          "line": 19,
          "snippet": "- write-back 대상은 GAME_FINISHED 또는 룸/게임 종료 시 DB 반영이 필수다."
        },
        {
          "path": "06_BACKEND/BE_TEST_RULES.md",
          "line": 37,
          "snippet": "## 4. 데이터 정합성 테스트"
        },
        {
          "path": "06_BACKEND/BE_TEST_RULES.md",
          "line": 38,
          "snippet": "- DTO → Entity 매핑 테스트를 작성한다."
        }
      ],
      "proposed_fix": "Extend `06_BACKEND/BE_TEST_RULES.md` with explicit test coverage statements for write-through persistence and write-back flush verification on GAME_FINISHED/room-or-game termination conditions."
    },
    {
      "task_id": "REL-API-FRONTEND",
      "agent_id": "relation-auditor",
      "target_kind": "relation",
      "target_id": "API_FRONTEND",
      "severity": "medium",
      "code": "PAGE_ROUTE_SCOPE_OVERGENERALIZATION",
      "message": "Frontend routing rule states transitions are only PageRoute-based/API `pageRoute`-based, but API SSOT defines non-pageRoute transition branches (e.g., login result and signup overlay), creating ambiguous contract usage boundaries.",
      "evidence": [
        {
          "path": "05_FRONTEND/FE_ROUTING_RULES.md",
          "line": 26,
          "snippet": "페이지 전환은 `PageRoute` 기준으로만 수행한다."
        },
        {
          "path": "05_FRONTEND/FE_ROUTING_RULES.md",
          "line": 27,
          "snippet": "API 응답의 `pageRoute`가 유일한 전환 기준이다."
        },
        {
          "path": "03_API/PAGE_MAP/WELCOME.md",
          "line": 24,
          "snippet": "data.result=OK -> active-game 조회 후 MAIN 또는 게임 페이지"
        },
        {
          "path": "03_API/PAGE_MAP/WELCOME.md",
          "line": 25,
          "snippet": "data.result=SIGNUP_REQUIRED -> WELCOME + SIGNUP 오버레이"
        }
      ],
      "proposed_fix": "전환 규칙을 active-game 복귀/게임 컨텍스트 전환에 한정해 `pageRoute`를 사용한다고 명시하고, 인증/가입/일반 내비게이션 전환은 PAGE_MAP 기준 별도 규칙으로 분리한다."
    },
    {
      "task_id": "REL-DESIGN-FRONTEND",
      "agent_id": "relation-auditor",
      "target_kind": "relation",
      "target_id": "DESIGN_FRONTEND",
      "severity": "medium",
      "code": "SCOPE_OWNERSHIP_DRIFT_WAITING_ROOM_LAYOUT",
      "message": "`WAITING_ROOM` page requirements include fixed player-grid placement rules, but both design and frontend area scopes exclude layout/component positioning. This creates ambiguous ownership for rules frontend is expected to consume.",
      "evidence": [
        {
          "path": "02_DESIGN/README.md",
          "line": 3,
          "snippet": "- 레이아웃/컴포넌트 위치/사이즈/화면 구성은 범위에서 제외한다."
        },
        {
          "path": "02_DESIGN/README.md",
          "line": 7,
          "snippet": "- 제외: 화면 레이아웃, UI 배치, 컴포넌트 위치/크기, 픽셀 기반 목업"
        },
        {
          "path": "02_DESIGN/PAGE_REQUIREMENTS/WAITING_ROOM.md",
          "line": 25,
          "snippet": "- 플레이어 그리드에서 방장은 항상 1행 1열에 위치한다."
        },
        {
          "path": "02_DESIGN/PAGE_REQUIREMENTS/WAITING_ROOM.md",
          "line": 28,
          "snippet": "- 방장 변경 시 신규 방장은 1행 1열로 이동한다."
        },
        {
          "path": "05_FRONTEND/README.md",
          "line": 7,
          "snippet": "- 제외: 화면 레이아웃/컴포넌트 배치, 디자인 목업"
        }
      ],
      "proposed_fix": "Move fixed slot/grid placement rules to the owning area (or explicitly assign ownership), and keep 02_DESIGN page requirements as non-positional data/state/interaction constraints that frontend can unambiguously consume."
    },
    {
      "task_id": "REL-DESIGN-FRONTEND",
      "agent_id": "relation-auditor",
      "target_kind": "relation",
      "target_id": "DESIGN_FRONTEND",
      "severity": "medium",
      "code": "NOTIFICATION_DOC_OWNERSHIP_DRIFT",
      "message": "Design declares `FE_NOTIFICATION_MESSAGES.md` inside `02_DESIGN/PAGE_REQUIREMENTS`, but the actual notification SSOT lives in `05_FRONTEND`. This creates cross-area ownership drift for page-level notification requirements.",
      "evidence": [
        {
          "path": "02_DESIGN/README.md",
          "line": 24,
          "snippet": "FE_NOTIFICATION_MESSAGES.md # 알림 및 오류 메시지 정의"
        },
        {
          "path": "02_DESIGN/PAGE_REQUIREMENTS/FE_NOTIFICATION_MESSAGES.md",
          "snippet": "Declared in 02_DESIGN file structure but file is not present in scoped path."
        },
        {
          "path": "05_FRONTEND/FE_NOTIFICATION_MESSAGES.md",
          "line": 2,
          "snippet": "- 알림 컴포넌트에서 사용하는 메시지 키와 한국어 문구를 단일 문서로 정의한다."
        }
      ],
      "proposed_fix": "Choose a single owner (recommended: `05_FRONTEND/FE_NOTIFICATION_MESSAGES.md`) and update `02_DESIGN/README.md` to reference that location explicitly instead of declaring it under `02_DESIGN/PAGE_REQUIREMENTS`."
    },
    {
      "task_id": "REL-DOMAIN-API",
      "agent_id": "relation-auditor",
      "target_kind": "relation",
      "target_id": "DOMAIN_API",
      "severity": "medium",
      "code": "REL_REQUIRED_LINK_PRESENCE_GAP",
      "message": "DOMAIN documents reference API contracts, but API contract docs do not reference DOMAIN SSOT docs, leaving DOMAIN_API traceability one-directional.",
      "evidence": [
        {
          "path": "04_DOMAIN/DATA_MODEL.md",
          "line": 12,
          "snippet": "- 03_API/CONTRACT/REST/OPENAPI.yaml.md"
        },
        {
          "path": "04_DOMAIN/REDIS_DB_TIMING.md",
          "line": 8,
          "snippet": "- [[03_API/LIFECYCLE.md]]"
        },
        {
          "path": "03_API/CONTRACT/REST/OPENAPI.yaml.md",
          "line": 30,
          "snippet": "- [[03_API/CONTRACT/REST/API_SUMMARY.md]]"
        },
        {
          "path": "03_API/CONTRACT/REALTIME/CONVENTIONS.md",
          "line": 7,
          "snippet": "- [[03_API/CONTRACT/REALTIME/TOPICS.md]]"
        }
      ],
      "proposed_fix": "Add explicit related-doc links from core API contract docs (e.g., `03_API/README.md`, `03_API/CONTRACT/REST/OPENAPI.yaml.md`, `03_API/CONTRACT/REALTIME/CONVENTIONS.md`) to `04_DOMAIN/DATA_MODEL.md` and, where relevant, `04_DOMAIN/REDIS_DB_TIMING.md`."
    },
    {
      "task_id": "REL-DOMAIN-API",
      "agent_id": "relation-auditor",
      "target_kind": "relation",
      "target_id": "DOMAIN_API",
      "severity": "medium",
      "code": "ENTITY_CONTRACT_STAGE_MAPPING_DRIFT",
      "message": "`ROOM_GAME_STARTED` event allows `PICK`/`SHOP` stages, but the domain transition model defines game start as `BAN` (RANKED) or `PLAY` (NORMAL), creating ambiguous Domain<->API stage semantics.",
      "evidence": [
        {
          "path": "04_DOMAIN/DATA_MODEL.md",
          "line": 674,
          "snippet": "- NORMAL: LOBBY → PLAY → FINISHED"
        },
        {
          "path": "04_DOMAIN/DATA_MODEL.md",
          "line": 675,
          "snippet": "- RANKED: LOBBY → BAN → PICK → SHOP → PLAY → FINISHED"
        },
        {
          "path": "03_API/CONTRACT/REALTIME/EVENTS.md",
          "line": 187,
          "snippet": "- stage: GameStage (BAN | PICK | SHOP | PLAY)"
        }
      ],
      "proposed_fix": "Constrain `ROOM_GAME_STARTED.data.stage` to `BAN | PLAY`, or clarify in the event spec that this event may represent post-start re-entry snapshots (and align domain text accordingly)."
    },
    {
      "task_id": "REL-PRODUCT-API",
      "agent_id": "relation-auditor",
      "target_kind": "relation",
      "target_id": "PRODUCT_API",
      "severity": "medium",
      "code": "PRODUCT_REQUIREMENT_TO_API_LINK_GAP",
      "message": "Product requirement documents reference API conceptually but do not provide explicit links to concrete API contracts, leaving requirement-to-contract traceability weak and audit mapping ambiguous.",
      "evidence": [
        {
          "path": "01_PRODUCT/USER_FLOWS.md",
          "line": 4,
          "snippet": "- 정책/권한/검증의 기준은 REQUIREMENTS / GAME_RULES / API 문서를 따른다."
        },
        {
          "path": "01_PRODUCT/USER_FLOWS.md",
          "line": 8,
          "snippet": "- [[01_PRODUCT/REQUIREMENTS.md]]"
        },
        {
          "path": "01_PRODUCT/REQUIREMENTS.md",
          "line": 6,
          "snippet": "- [[01_PRODUCT/GAME_RULES.md]]"
        },
        {
          "path": "03_API/LIFECYCLE.md",
          "line": 6,
          "snippet": "- [[01_PRODUCT/USER_FLOWS.md]]"
        }
      ],
      "proposed_fix": "Add explicit cross-links from `01_PRODUCT/REQUIREMENTS.md` and `01_PRODUCT/USER_FLOWS.md` to concrete API artifacts (at minimum `03_API/PAGE_MAP/*.md` and `03_API/CONTRACT/REST/OPENAPI.yaml.md`), and optionally introduce requirement IDs for deterministic requirement-to-contract mapping."
    },
    {
      "task_id": "REL-PRODUCT-DESIGN",
      "agent_id": "relation-auditor",
      "target_kind": "relation",
      "target_id": "PRODUCT_DESIGN",
      "severity": "medium",
      "code": "REL_INTENT_TO_DESIGN_MAPPING_IMPLICIT",
      "message": "Design page requirements are organized by page but do not map each requirement block to specific Product intent clauses, reducing traceability and making drift detection difficult.",
      "evidence": [
        {
          "path": "01_PRODUCT/REQUIREMENTS.md",
          "line": 100,
          "snippet": "게임과 직접 관련된 페이지는 다음 네 개로 고정한다."
        },
        {
          "path": "01_PRODUCT/USER_FLOWS.md",
          "line": 15,
          "snippet": "게임과 직접적으로 연관된 페이지는 아래 4개로 고정된다."
        },
        {
          "path": "02_DESIGN/PAGE_REQUIREMENTS/WAITING_ROOM.md",
          "line": 4,
          "snippet": "## 관련 문서"
        },
        {
          "path": "02_DESIGN/PAGE_REQUIREMENTS/WAITING_ROOM.md",
          "line": 5,
          "snippet": "- [[03_API/PAGE_MAP/WAITING_ROOM.md]]"
        },
        {
          "path": "02_DESIGN/PAGE_REQUIREMENTS/LOGIN.md",
          "line": 4,
          "snippet": "## 관련 문서"
        },
        {
          "path": "02_DESIGN/PAGE_REQUIREMENTS/LOGIN.md",
          "line": 5,
          "snippet": "- [[03_API/PAGE_MAP/WELCOME.md]]"
        }
      ],
      "proposed_fix": "For each Design page spec, add a `Source Intent` section that links to exact Product sections (anchor-level) for `Required Data`, `Required States`, and `Interactions`."
    },
    {
      "task_id": "REL-PRODUCT-DESIGN",
      "agent_id": "relation-auditor",
      "target_kind": "relation",
      "target_id": "PRODUCT_DESIGN",
      "severity": "medium",
      "code": "REL_DUPLICATED_BEHAVIORAL_RULES",
      "message": "Behavioral norms are duplicated between Product and Design documents without explicit derivation links, creating non-SSOT duplication and future conflict risk.",
      "evidence": [
        {
          "path": "01_PRODUCT/REQUIREMENTS.md",
          "line": 95,
          "snippet": "- PICK 단계에서는 최종 BAN 알고리즘이 선택 불가 처리되어야 한다(별도 알림 UI 없음)."
        },
        {
          "path": "02_DESIGN/PAGE_REQUIREMENTS/BAN_PICK_SHOP.md",
          "line": 29,
          "snippet": "- GAME_BAN_FINALIZED 수신 이후 PICK 단계에서 최종 BAN 알고리즘을 선택 불가 처리한다(별도 알림 없음)."
        },
        {
          "path": "01_PRODUCT/REQUIREMENTS.md",
          "line": 73,
          "snippet": "- 방장 위임 성공 시 대상은 READY 상태로 전환되며, 대기실 UI에서 방장 표시가 갱신되어야 한다."
        },
        {
          "path": "02_DESIGN/PAGE_REQUIREMENTS/WAITING_ROOM.md",
          "line": 24,
          "snippet": "- 방장 위임 성공 이벤트(ROOM_HOST_CHANGED, reason=MANUAL)에서 대상이 본인이면 알림 컴포넌트로 `NOTICE.HOST_TRANSFERRED`를 표시한다."
        }
      ],
      "proposed_fix": "Keep policy rules authoritative in `01_PRODUCT/*`; in `02_DESIGN/*` replace repeated policy text with explicit `derived-from` references and retain only UI state/rendering requirements."
    },
    {
      "task_id": "DUP-NORMATIVE",
      "agent_id": "duplication-auditor",
      "target_kind": "duplication",
      "target_id": "NORMATIVE_DUPLICATION",
      "severity": "medium",
      "code": "NORMATIVE_CONFLICT_WRITEBACK_TIMING",
      "message": "Write-back timing guidance is internally conflicting for ROOM* entities: some docs require game-start DB flush, while DB_NOTES states write-back as end-of-game reflection.",
      "evidence": [
        {
          "path": "04_DOMAIN/DATA_MODEL.md",
          "line": 58,
          "snippet": "| ROOM | write-back | 로비 상태는 Redis에서 관리, 게임 시작 시 DB 스냅샷 저장 |"
        },
        {
          "path": "04_DOMAIN/DATA_MODEL.md",
          "line": 60,
          "snippet": "| ROOM_KICK | write-back | 로비 단계 기록은 Redis에 유지, 게임 시작 시 DB 저장 |"
        },
        {
          "path": "04_DOMAIN/REDIS_DB_TIMING.md",
          "line": 26,
          "snippet": "| Phase 1: 게임 시작 | startGame | 스냅샷 고정 | 1차 DB flush | ROOM, ROOM_PLAYER, ROOM_KICK, ROOM_HOST_HISTORY, GAME, GAME_PLAYER |"
        },
        {
          "path": "04_DOMAIN/DB_NOTES.md",
          "line": 105,
          "snippet": "- 예외: ROOM, ROOM_PLAYER, ROOM_KICK, ROOM_HOST_HISTORY, GAME, GAME_PLAYER, GAME_BAN, GAME_PICK은 write-back(종료 시 DB 반영)."
        },
        {
          "path": "04_DOMAIN/DB_NOTES.md",
          "line": 106,
          "snippet": "- 최종 기준은 DATA_MODEL.md의 Write Policy 매핑을 따른다."
        }
      ],
      "proposed_fix": "Normalize DB_NOTES.md to the same phase-specific timing as DATA_MODEL.md/REDIS_DB_TIMING.md (game-start flush for ROOM* lobby artifacts, GAME_FINISHED flush for game-progress artifacts), or replace the conflicting sentence with a direct reference to DATA_MODEL.md mapping only."
    },
    {
      "task_id": "DUP-OWNERSHIP",
      "agent_id": "duplication-auditor",
      "target_kind": "duplication",
      "target_id": "OWNERSHIP_VIOLATION",
      "severity": "medium",
      "code": "cross_area_redefinition.copy_ownership_drift",
      "message": "Design page requirement docs and Frontend state rules repeatedly state that alert copy is managed by Frontend, which conflicts with Product’s declared ownership of UI copy SSOT and creates ambiguous cross-area ownership.",
      "evidence": [
        {
          "path": "02_DESIGN/PAGE_REQUIREMENTS/LOGIN.md",
          "line": 23,
          "snippet": "- 알림 문구는 서버 `error.code` 기준으로 프론트엔드에서 관리한다."
        },
        {
          "path": "02_DESIGN/PAGE_REQUIREMENTS/BAN_PICK_SHOP.md",
          "line": 33,
          "snippet": "- 알림 문구는 서버 `error.code` 기준으로 프론트엔드에서 관리한다."
        },
        {
          "path": "05_FRONTEND/FE_STATE_RULES.md",
          "line": 44,
          "snippet": "- 서버 응답의 `error.code`에 대한 안내 문구는 프론트엔드에서 관리한다."
        },
        {
          "path": "01_PRODUCT/COPY_TEXT.md",
          "line": 2,
          "snippet": "- UI 문구는 이 파일이 단일 진실"
        }
      ],
      "proposed_fix": "Replace ownership statements in Design/Frontend docs with reference-only wording: Frontend renders Product-owned copy keys, and copy source-of-truth changes are made only under `01_PRODUCT/`."
    },
    {
      "task_id": "DUP-TERMINOLOGY",
      "agent_id": "duplication-auditor",
      "target_kind": "duplication",
      "target_id": "TERM_CONFLICT",
      "severity": "medium",
      "code": "ALIAS_WITHOUT_MAPPING_ROOM_LIST_ROUTE_STATE",
      "message": "`ROOM_LIST` is defined upstream as a MAIN-internal panel state, but frontend design mapping labels it as `Route` without an explicit canonical mapping (route vs panel-state key). This creates alias ambiguity and weak traceability.",
      "evidence": [
        {
          "path": "01_PRODUCT/USER_FLOWS.md",
          "line": 26,
          "snippet": "ROOM_LIST 패널 상태 (MAIN 헤더 하단 교체 상태)"
        },
        {
          "path": "03_API/PAGE_MAP/ROOM_LIST.md",
          "line": 2,
          "snippet": "MAIN 내부 ROOM_LIST 패널 상태의 방 탐색/참가 및 목록 동기화..."
        },
        {
          "path": "05_FRONTEND/FE_DESIGN_MAPPING.md",
          "line": 12,
          "snippet": "## 1. 페이지 매핑 (Route → Data Requirements)"
        },
        {
          "path": "05_FRONTEND/FE_DESIGN_MAPPING.md",
          "line": 17,
          "snippet": "| ROOM_LIST | [[02_DESIGN/PAGE_REQUIREMENTS/ROOM_LIST.md]] | MAIN 내 패널 상태"
        }
      ],
      "proposed_fix": "Make the mapping term explicit as `Route/State` (or split columns), and encode ROOM_LIST as a MAIN substate key (e.g., `MAIN.ROOM_LIST_PANEL`) rather than a standalone route identifier."
    },
    {
      "task_id": "AGENTSPEC-BACKEND",
      "agent_id": "agent-spec-auditor",
      "target_kind": "agent_spec",
      "target_id": "BACKEND_AGENT_SKILL",
      "severity": "medium",
      "code": "required_reference_existence.backend_readme_unqualified_agent_paths",
      "message": "`AGENTS/CLAUDE/AGENTS/BACKEND/README.md` lists many agent files as bare filenames that do not exist relative to that directory, reducing SSOT traceability and causing ambiguous ownership navigation.",
      "evidence": [
        {
          "path": "AGENTS/CLAUDE/AGENTS/BACKEND/README.md",
          "line": 22,
          "snippet": "Review Master: `BE_REVIEW_MASTER_AGENT.md`"
        },
        {
          "path": "AGENTS/CLAUDE/AGENTS/BACKEND/README.md",
          "line": 24,
          "snippet": "Dev Master: `BE_DEV_MASTER_AGENT.md`"
        },
        {
          "path": "AGENTS/CLAUDE/AGENTS/BACKEND/README.md",
          "line": 33,
          "snippet": "`CORE_INFRA_REVIEW_AGENT.md` | `BE_DEV_CORE_INFRA_AGENT.md`"
        },
        {
          "path": "AGENTS/CLAUDE/AGENTS/BACKEND/README.md",
          "line": 40,
          "snippet": "`JPA_DB_REVIEW_AGENT.md` | `BE_DEV_JPA_DB_AGENT.md`"
        }
      ],
      "proposed_fix": "Replace bare filenames with explicit relative paths (e.g., `REVIEW/BE_REVIEW_MASTER_AGENT.md`, `DEV/BE_DEV_MASTER_AGENT.md`) and keep naming/path conventions consistent across all table entries."
    },
    {
      "task_id": "TRACE-E2E",
      "agent_id": "traceability-auditor",
      "target_kind": "traceability",
      "target_id": "E2E_TRACEABILITY",
      "severity": "medium",
      "code": "TRACE_ORPHAN_SPEC_DECLARATION_FE_NOTIFICATION",
      "message": "An orphan/misaligned spec declaration exists: Design README declares `FE_NOTIFICATION_MESSAGES.md` under `02_DESIGN/PAGE_REQUIREMENTS`, but the actual document lives in Frontend docs and is consumed there.",
      "evidence": [
        {
          "path": "02_DESIGN/README.md",
          "line": 24,
          "snippet": "FE_NOTIFICATION_MESSAGES.md # 알림 및 오류 메시지 정의"
        },
        {
          "path": "02_DESIGN/PAGE_REQUIREMENTS/FE_NOTIFICATION_MESSAGES.md",
          "snippet": "Declared in README path, but file is absent in `02_DESIGN/PAGE_REQUIREMENTS`."
        },
        {
          "path": "05_FRONTEND/FE_STATE_RULES.md",
          "line": 9,
          "snippet": "- [[05_FRONTEND/FE_NOTIFICATION_MESSAGES.md]]"
        },
        {
          "path": "05_FRONTEND/FE_NOTIFICATION_MESSAGES.md",
          "line": 2,
          "snippet": "- 알림 컴포넌트에서 사용하는 메시지 키와 한국어 문구를 단일 문서로 정의한다."
        }
      ],
      "proposed_fix": "Choose a single owner and canonical path for notification-message SSOT; either add the declared Design file or update `02_DESIGN/README.md` to reference `05_FRONTEND/FE_NOTIFICATION_MESSAGES.md` explicitly."
    },
    {
      "task_id": "AREA-06_BACKEND",
      "agent_id": "area-auditor",
      "target_kind": "area",
      "target_id": "06_BACKEND",
      "severity": "low",
      "code": "REQUIRED_DOC_DECLARED_BUT_MISSING",
      "message": "`06_BACKEND/README.md` declares `BE_AGENT_SPLIT.md` in the backend file structure, but that file is missing in the scoped area.",
      "evidence": [
        {
          "path": "06_BACKEND/README.md",
          "line": 19,
          "snippet": "BE_AGENT_SPLIT.md # 병렬 에이전트 분할 기준"
        },
        {
          "path": "06_BACKEND/BE_AGENT_SPLIT.md"
        }
      ],
      "proposed_fix": "Either add `06_BACKEND/BE_AGENT_SPLIT.md` with the intended backend agent split criteria or remove/update the stale entry in `06_BACKEND/README.md`."
    },
    {
      "task_id": "DUP-NORMATIVE",
      "agent_id": "duplication-auditor",
      "target_kind": "duplication",
      "target_id": "NORMATIVE_DUPLICATION",
      "severity": "low",
      "code": "NORMATIVE_DUPLICATION_SCALING_BASELINE",
      "message": "The same normative scaling statement ('1920x1080 is conversion baseline, not fixed resolution rule') is duplicated across DESIGN and FRONTEND docs despite FRONTEND already declaring DESIGN as source-of-truth, increasing drift risk.",
      "evidence": [
        {
          "path": "02_DESIGN/TYPOGRAPHY_SYSTEM.md",
          "line": 5,
          "snippet": "- 1920x1080은 **환산 기준**이며 고정 해상도 규칙이 아니다."
        },
        {
          "path": "05_FRONTEND/FE_STYLING.md",
          "line": 3,
          "snippet": "- 디자인의 단일 진실은 [[02_DESIGN/COLOR_SYSTEM.md]], [[02_DESIGN/TYPOGRAPHY_SYSTEM.md]]이며, 본 문서는 적용 방식만 기술한다."
        },
        {
          "path": "05_FRONTEND/FE_STYLING.md",
          "line": 12,
          "snippet": "- 1920x1080은 **환산 기준**이며 고정 해상도 규칙이 아니다."
        },
        {
          "path": "05_FRONTEND/FE_CONVENTIONS.md",
          "line": 47,
          "snippet": "- 1920x1080은 **환산 기준**이며 고정 해상도 규칙이 아니다."
        }
      ],
      "proposed_fix": "Keep the normative baseline in DESIGN docs only, and in FRONTEND docs replace duplicated normative text with a short reference pointer to the DESIGN source."
    }
  ],
  "open_actions": [
    {
      "task_id": "REL-PRODUCT-DESIGN",
      "target": "relation/PRODUCT_DESIGN",
      "severity": "critical",
      "code": "REL_MISSING_MANDATORY_CROSS_REF",
      "action": "Add explicit PRODUCT_DESIGN links in both directions: each `02_DESIGN/PAGE_REQUIREMENTS/*.md` should cite source clauses in `01_PRODUCT/REQUIREMENTS.md` and/or `01_PRODUCT/USER_FLOWS.md`, and Product should reference corresponding Design requirement docs for downstream realization."
    },
    {
      "task_id": "DUP-OWNERSHIP",
      "target": "duplication/OWNERSHIP_VIOLATION",
      "severity": "critical",
      "code": "source_of_truth_violation.copy_ssot_redefined",
      "action": "Move canonical alert/message keys and Korean copy definitions into `01_PRODUCT/COPY_TEXT.md` (or a Product-owned copy SSOT file), and convert `05_FRONTEND/FE_NOTIFICATION_MESSAGES.md` into implementation guidance that only references Product-owned keys."
    },
    {
      "task_id": "TRACE-E2E",
      "target": "traceability/E2E_TRACEABILITY",
      "severity": "critical",
      "code": "TRACE_REQ_DESIGN_MANDATORY_LINK_MISSING",
      "action": "Add explicit `Source Requirement` links (section-level anchors) from each `02_DESIGN/PAGE_REQUIREMENTS/*.md` to `01_PRODUCT/REQUIREMENTS.md` and/or `01_PRODUCT/USER_FLOWS.md`, and add reverse links from Product pages to corresponding Design specs."
    },
    {
      "task_id": "AREA-05_FRONTEND",
      "target": "area/05_FRONTEND",
      "severity": "high",
      "code": "ROUTING_PAGE_ROUTE_CONTRACT_MISMATCH",
      "action": "Separate frontend app routes from API `PageRoute` (e.g., `AppRoute` vs `ApiPageRoute`) or align FE route lists to the API contract, then update `05_FRONTEND/FE_ROUTING_RULES.md` and `05_FRONTEND/FE_DESIGN_MAPPING.md` accordingly."
    },
    {
      "task_id": "REL-API-FRONTEND",
      "target": "relation/API_FRONTEND",
      "severity": "high",
      "code": "PAGE_ROUTE_ENUM_MISMATCH",
      "action": "`05_FRONTEND/FE_ROUTING_RULES.md`에서 `PageRoute`를 active-game 복귀용 3개 값으로 한정하고, 일반 화면 라우트 식별자는 별도 타입(예: `AppRoute`)으로 분리해 정의한다."
    },
    {
      "task_id": "REL-DOMAIN-BACKEND",
      "target": "relation/DOMAIN_BACKEND",
      "severity": "high",
      "code": "DOMAIN_BACKEND_WRITE_POLICY_TIMING_MISMATCH",
      "action": "Update `06_BACKEND/BE_DATA_MODEL_RULES.md` to mirror domain SSOT timing by entity group: `ROOM/ROOM_PLAYER/ROOM_KICK/ROOM_HOST_HISTORY` flush at `startGame`, and `GAME/GAME_PLAYER/GAME_BAN/GAME_PICK` flush at `GAME_FINISHED`; keep wording aligned with `04_DOMAIN/DATA_MODEL.md` and `04_DOMAIN/REDIS_DB_TIMING.md`."
    },
    {
      "task_id": "REL-PRODUCT-API",
      "target": "relation/PRODUCT_API",
      "severity": "high",
      "code": "LIFECYCLE_BAN_PICK_ENDPOINT_CONFLICT",
      "action": "In `03_API/LIFECYCLE.md` section 5.3, split BAN/PICK/SHOP into separate rows and map each to the correct endpoint (`/ban`, `/pick`, `/shop/purchase`) to match PAGE_MAP and OPENAPI contracts."
    },
    {
      "task_id": "DUP-NORMATIVE",
      "target": "duplication/NORMATIVE_DUPLICATION",
      "severity": "high",
      "code": "NORMATIVE_CONFLICT_UI_MESSAGE_SSOT",
      "action": "Define one canonical ownership model: either (a) move ERROR/NOTICE message keys and localized strings into 01_PRODUCT/COPY_TEXT.md and make FE docs reference-only, or (b) carve out explicit notification exceptions in FE_CONVENTIONS/FE_API_CLIENT and update 01_PRODUCT/COPY_TEXT.md scope text accordingly."
    },
    {
      "task_id": "DUP-TERMINOLOGY",
      "target": "duplication/TERM_CONFLICT",
      "severity": "high",
      "code": "TERM_DEFINITION_CONFLICT_PAGEROUTE",
      "action": "Reserve `PageRoute` for API active-game values only (`WAITING_ROOM`, `BAN_PICK_SHOP`, `IN_GAME`). Introduce a separate term (e.g., `AppRoute`) for full frontend navigation routes and document explicit mapping between `pageRoute` -> `AppRoute` where needed."
    },
    {
      "task_id": "AGENTSPEC-BACKEND",
      "target": "agent_spec/BACKEND_AGENT_SKILL",
      "severity": "high",
      "code": "required_reference_existence.partial_review_docs_path_missing",
      "action": "Make the docs location configurable (e.g., env var or skill input), validate existence before execution, and add a fallback prompt when unavailable. If `../docs` is truly mandatory, document/bootstrap that dependency so the path is always present."
    },
    {
      "task_id": "TRACE-E2E",
      "target": "traceability/E2E_TRACEABILITY",
      "severity": "high",
      "code": "TRACE_API_BAN_PICK_SHOP_MAPPING_CONFLICT",
      "action": "In `03_API/LIFECYCLE.md` section 5.3, split BAN, PICK, and SHOP into separate rows with the correct endpoints (`/ban`, `/pick`, `/shop/purchase`) so lifecycle, page-map, and downstream implementation traces stay consistent."
    },
    {
      "task_id": "TRACE-E2E",
      "target": "traceability/E2E_TRACEABILITY",
      "severity": "high",
      "code": "TRACE_DOMAIN_BACKEND_WRITE_POLICY_TIMING_MISMATCH",
      "action": "Align `06_BACKEND/BE_DATA_MODEL_RULES.md` with domain timing semantics: ROOM* flush at `startGame`, GAME* flush at `GAME_FINISHED`, using the same entity-group mapping as `04_DOMAIN`."
    },
    {
      "task_id": "TRACE-E2E",
      "target": "traceability/E2E_TRACEABILITY",
      "severity": "high",
      "code": "TRACE_API_FRONTEND_PAGEROUTE_ENUM_MISMATCH",
      "action": "Use API `PageRoute` only for active-game transitions (`WAITING_ROOM`, `BAN_PICK_SHOP`, `IN_GAME`) and define a separate frontend route type (e.g., `AppRoute`) for general navigation."
    }
  ]
}
