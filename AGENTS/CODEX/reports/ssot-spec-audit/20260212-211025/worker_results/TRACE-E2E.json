{
  "run_id": "20260212-211025",
  "agent_id": "traceability-auditor",
  "task_id": "TRACE-E2E",
  "target": {
    "kind": "traceability",
    "id": "E2E_TRACEABILITY"
  },
  "status": "fail",
  "summary": "End-to-end traceability is broken by missing Product→Design source links, API lifecycle mapping conflict, Domain→Backend write-policy timing mismatch, API→Frontend PageRoute mismatch, and one orphaned/mislocated spec declaration.",
  "findings": [
    {
      "severity": "critical",
      "code": "TRACE_REQ_DESIGN_MANDATORY_LINK_MISSING",
      "message": "The requirement-to-design segment is missing explicit mandatory references: Product requirement sources link only within `01_PRODUCT`, while Design page requirements link directly to API docs, leaving the `requirement -> design -> api` chain non-deterministic.",
      "dedupe_key": "trace:req-design:missing-mandatory-links",
      "evidence": [
        {
          "path": "01_PRODUCT/REQUIREMENTS.md",
          "line": 5,
          "snippet": "## 관련 문서"
        },
        {
          "path": "01_PRODUCT/REQUIREMENTS.md",
          "line": 6,
          "snippet": "- [[01_PRODUCT/GAME_RULES.md]]"
        },
        {
          "path": "01_PRODUCT/USER_FLOWS.md",
          "line": 7,
          "snippet": "## 관련 문서"
        },
        {
          "path": "02_DESIGN/PAGE_REQUIREMENTS/MAIN.md",
          "line": 5,
          "snippet": "- [[03_API/PAGE_MAP/MAIN.md]]"
        },
        {
          "path": "02_DESIGN/README.md",
          "line": 28,
          "snippet": "- 페이지 요구사항(데이터/상태/상호작용)은 `03_API/PAGE_MAP/`과 일치해야 한다."
        }
      ],
      "proposed_fix": "Add explicit `Source Requirement` links (section-level anchors) from each `02_DESIGN/PAGE_REQUIREMENTS/*.md` to `01_PRODUCT/REQUIREMENTS.md` and/or `01_PRODUCT/USER_FLOWS.md`, and add reverse links from Product pages to corresponding Design specs."
    },
    {
      "severity": "high",
      "code": "TRACE_API_BAN_PICK_SHOP_MAPPING_CONFLICT",
      "message": "API lifecycle documentation contains conflicting BAN/PICK/SHOP REST mappings, which can miswire requirement/design-driven orchestration.",
      "dedupe_key": "trace:api:lifecycle-ban-pick-shop-conflict",
      "evidence": [
        {
          "path": "03_API/LIFECYCLE.md",
          "line": 73,
          "snippet": "- REST `/games/{gameId}/ban`, `/pick`, `/shop/purchase`"
        },
        {
          "path": "03_API/LIFECYCLE.md",
          "line": 137,
          "snippet": "| BAN/PICK/SHOP 구매         | `POST /games/{gameId}/shop/purchase` | 밴/픽/구매 처리              |"
        },
        {
          "path": "03_API/PAGE_MAP/BAN_PICK_SHOP.md",
          "line": 23,
          "snippet": "| BAN | 알고리즘 밴 제출 | POST | /games/{gameId}/ban |"
        },
        {
          "path": "03_API/PAGE_MAP/BAN_PICK_SHOP.md",
          "line": 24,
          "snippet": "| PICK | 알고리즘 픽 제출 | POST | /games/{gameId}/pick |"
        },
        {
          "path": "03_API/PAGE_MAP/BAN_PICK_SHOP.md",
          "line": 25,
          "snippet": "| SHOP | 아이템/스펠 일괄 구매 | POST | /games/{gameId}/shop/purchase |"
        }
      ],
      "proposed_fix": "In `03_API/LIFECYCLE.md` section 5.3, split BAN, PICK, and SHOP into separate rows with the correct endpoints (`/ban`, `/pick`, `/shop/purchase`) so lifecycle, page-map, and downstream implementation traces stay consistent."
    },
    {
      "severity": "high",
      "code": "TRACE_DOMAIN_BACKEND_WRITE_POLICY_TIMING_MISMATCH",
      "message": "The requirement-to-domain-to-backend chain is inconsistent for write-back timing: backend rule text allows a broad end-of-room/game flush, while domain SSOT requires phase-specific timing by entity group.",
      "dedupe_key": "trace:domain-backend:write-policy-timing-mismatch",
      "evidence": [
        {
          "path": "06_BACKEND/BE_DATA_MODEL_RULES.md",
          "line": 19,
          "snippet": "- write-back 대상은 GAME_FINISHED 또는 룸/게임 종료 시 DB 반영이 필수다."
        },
        {
          "path": "04_DOMAIN/DATA_MODEL.md",
          "line": 58,
          "snippet": "| ROOM | write-back | 로비 상태는 Redis에서 관리, 게임 시작 시 DB 스냅샷 저장 |"
        },
        {
          "path": "04_DOMAIN/DATA_MODEL.md",
          "line": 62,
          "snippet": "| GAME | write-back | 진행 상태는 Redis에서 관리, GAME_FINISHED 시 DB 저장 |"
        },
        {
          "path": "04_DOMAIN/REDIS_DB_TIMING.md",
          "line": 26,
          "snippet": "| Phase 1: 게임 시작 | startGame | 스냅샷 고정 | 1차 DB flush | ROOM, ROOM_PLAYER, ROOM_KICK, ROOM_HOST_HISTORY, GAME, GAME_PLAYER |"
        },
        {
          "path": "04_DOMAIN/REDIS_DB_TIMING.md",
          "line": 28,
          "snippet": "| Phase 3: 게임 종료 | GAME_FINISHED | 최종 스냅샷 | 2차 DB flush | GAME, GAME_PLAYER, GAME_BAN, GAME_PICK, USER(coin/exp/score) |"
        }
      ],
      "proposed_fix": "Align `06_BACKEND/BE_DATA_MODEL_RULES.md` with domain timing semantics: ROOM* flush at `startGame`, GAME* flush at `GAME_FINISHED`, using the same entity-group mapping as `04_DOMAIN`."
    },
    {
      "severity": "high",
      "code": "TRACE_API_FRONTEND_PAGEROUTE_ENUM_MISMATCH",
      "message": "Frontend routing rules redefine API `PageRoute` scope, breaking API-to-frontend traceability for active-game routing decisions required by product flow.",
      "dedupe_key": "trace:api-frontend:pageroute-enum-mismatch",
      "evidence": [
        {
          "path": "01_PRODUCT/USER_FLOWS.md",
          "line": 37,
          "snippet": "- active game 있음: 해당 게임의 현재 stage에 맞는 게임 페이지로 이동한다."
        },
        {
          "path": "03_API/CONTRACT/REST/CONVENTIONS.md",
          "line": 137,
          "snippet": "PageRoute 값은 다음 3개만 사용한다."
        },
        {
          "path": "03_API/CONTRACT/REST/OPENAPI.yaml.md",
          "line": 131,
          "snippet": "enum: [WAITING_ROOM, BAN_PICK_SHOP, IN_GAME]"
        },
        {
          "path": "05_FRONTEND/FE_ROUTING_RULES.md",
          "line": 14,
          "snippet": "- Route name은 `PageRoute`와 동일한 대문자 식별자를 사용한다."
        },
        {
          "path": "05_FRONTEND/FE_ROUTING_RULES.md",
          "line": 16,
          "snippet": "- 예: `WELCOME`, `MAIN`, `WAITING_ROOM`, `BAN_PICK_SHOP`, `IN_GAME`, `RESULT`, `MY_PAGE`"
        },
        {
          "path": "05_FRONTEND/FE_ROUTING_RULES.md",
          "line": 27,
          "snippet": "- API 응답의 `pageRoute`가 유일한 전환 기준이다."
        }
      ],
      "proposed_fix": "Use API `PageRoute` only for active-game transitions (`WAITING_ROOM`, `BAN_PICK_SHOP`, `IN_GAME`) and define a separate frontend route type (e.g., `AppRoute`) for general navigation."
    },
    {
      "severity": "medium",
      "code": "TRACE_ORPHAN_SPEC_DECLARATION_FE_NOTIFICATION",
      "message": "An orphan/misaligned spec declaration exists: Design README declares `FE_NOTIFICATION_MESSAGES.md` under `02_DESIGN/PAGE_REQUIREMENTS`, but the actual document lives in Frontend docs and is consumed there.",
      "dedupe_key": "trace:orphan:design-fe-notification-path-drift",
      "evidence": [
        {
          "path": "02_DESIGN/README.md",
          "line": 24,
          "snippet": "FE_NOTIFICATION_MESSAGES.md # 알림 및 오류 메시지 정의"
        },
        {
          "path": "02_DESIGN/PAGE_REQUIREMENTS/FE_NOTIFICATION_MESSAGES.md",
          "snippet": "Declared in README path, but file is absent in `02_DESIGN/PAGE_REQUIREMENTS`."
        },
        {
          "path": "05_FRONTEND/FE_STATE_RULES.md",
          "line": 9,
          "snippet": "- [[05_FRONTEND/FE_NOTIFICATION_MESSAGES.md]]"
        },
        {
          "path": "05_FRONTEND/FE_NOTIFICATION_MESSAGES.md",
          "line": 2,
          "snippet": "- 알림 컴포넌트에서 사용하는 메시지 키와 한국어 문구를 단일 문서로 정의한다."
        }
      ],
      "proposed_fix": "Choose a single owner and canonical path for notification-message SSOT; either add the declared Design file or update `02_DESIGN/README.md` to reference `05_FRONTEND/FE_NOTIFICATION_MESSAGES.md` explicitly."
    }
  ],
  "metrics": {
    "files_scanned": 64,
    "links_checked": 194,
    "relations_checked": 4
  },
  "started_at": "2026-02-12T12:10:25Z",
  "finished_at": "2026-02-12T12:24:29Z"
}
